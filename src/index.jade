doctype html
html
  head
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')
    title Elm or FUD

    link(rel='stylesheet', type='text/css', href='build/build.css')

  body

    article
      // INTRO
      section(data-bespoke-backdrop='elm')
        .content
          h1.bullet Elm <small>or</small> FUD
          h3.bullet Hunting Bugs with the Compiler
          br
          br
          pre.bullet
            code.elm
              | { name    = "Chandu Tennety"
              | , company = "Instructure"
              | , twitter = "tennety"
              | , github  = "tennety"
              | }


      section
        .content
          h2 Why Elm?
          h3.bullet ...and why should I care?

          img.bullet(src="/images/elmer.png")
          img.bullet(src="/images/undef.jpg")

        aside
          p JavaScript programmers are like Elmer Fudd.
          p Every morning we pull out our ES6 "fat arrows" and go hunting.
          p So what does that make JavaScript? Bugs Bunny.
          p `undefined is not a function` is like "Eh, what's up doc?"
          p Bugs shows up and whacks us in the head with a giant hammer and we go "Oh, yeah, that's right."
          p We get so used to keeping all those possibilities in our head.


      section
        .content
          img.bullet(src="/images/elmer-iron-man.jpg")

        aside
          p Elm turns us into Iron Man.


      section
        .content
          h2 Why Elm?
          h3.bullet ...and why should I care?
          br
          ul
            li Fully functional, compile-to-JS
            li Zealously helpful compiler
            li Built for reactive UIs, supports FRP out of the box
            li Approachable, friendly community

        aside
          p We'll talk about more language features (and how they help) in a bit.
          p Helpful error messages, diffs, hints...like, <em>really</em> helpful.
          p HTML/CSS, Canvas, Native?
          p This is the best part. Slack channel, github, google groups.
          p Let's go over each in more detail.


      // FEATURES
      section(data-bespoke-backdrop='elm')
        .content
          h1 Language Features


      section
        .content
          h2.bullet Language Features
          br
          br
          ul
            li Static types
            li Immutable data structures
            li Pure functions
            li JS interoperability

        aside
          p Static typing provides guarantees that help eliminate a whole class of runtime errors.
          p Immutability guarantees referential transparency and that a set of data transformations always returns the same results.
          p Pure functions allow fast reasoning without worrying about side effects to the state.
          p Interop allows powerful yet controlled access to the native/host environment


      section
        .content
          h2 Language Features
          h4.bullet Static types
          br
          ul
            li Defining the "shape" of data
            li Contracts between functions and data
            li Eliminating nulls

        aside
          p Static types often create FUD among programmers used to dynamically typed languages.
          p I've used Ruby, JS, and Clojure, and one thing they all share is a conscious desire to distance themselves from languages like Java.
          p But there's a distinction between types (or classes and interfaces) in Java and types in functional languages.
          p Types in Elm serve to define <em>contracts</em> between functions and the data they work with.
          p These contracts let the compiler guide you away from ever letting bad data in.
          p This has less to do with VM optimization, and more with helping the programmer work with a smaller mental overhead.


      section
        .content
          h2 Language Features
          h4.bullet Static types
          pre.bullet
            code.elm
              | longestNameLength: List String -> Maybe Int
              | longestNameLength nameList =
              |   List.maximum (List.map String.length nameList)
          br
          pre.bullet
            code.elm
              | longestNameLength ["Tony", "Steve", "T'Challa"]
              | -- Just 8 : Maybe.Maybe Int
            code.bullet.elm
              | longestNameLength [] -- Nothing : Maybe.Maybe Int
            code.bullet.elm
              | longestNameLength [1, 2] -- Compile error
            code.bullet.elm
              | longestNameLength ["Peter", 2] -- Compile error

        aside
          p The type annotation is optional, Elm can infer the input and output types
          p The Maybe type kills null. The function explicitly tells you it may return Nothing, so you <em>have</em> to handle it.
          p Our function expects a List of Strings, because only then can it successfully call String.length on the List.
          p Giving it other types in the List causes compile errors.
          p List's `head` and `tail` functions return Maybes to deal with empty lists.


      section
        .content
          h3.bullet Doing this in JavaScript?
          img.bullet(src="/images/doc.png")


      section
        .content
          h2 Language Features
          h4.bullet Static types
          pre.bullet
            code.elm
              | type Maybe a = Just a | Nothing
          br
          pre.bullet
            code.elm
              | message: Maybe Int -> String
              | message length =
              |   case length of
              |     Just num ->
              |       "The longest name is " ++ (toString num) ++ " characters."
              |     Nothing  ->
              |       "You gotta give me something to work with here."

        aside
          p Static types give us powerful ways of working with expectations.
          p This is different from OOP land, where you may expect a subclass or check if an object responds to a method.
          p Maybe here is an example of a Union Type or Tagged Union, where the type can carry additional values.
          p As soon as the compiler sees the case, it will not let you terminate it without handling all possible values of the type.


      section
        .content
          h2 Language Features
          h4.bullet Static types
          pre
            code.elm
              |-- type Maybe a = Just a | Nothing
              |-- message: Maybe Int -> String
          br
          pre.bullet
            code.elm
              | message (longestNameLength ["Sharon Carter", "Natasha Romanoff"])
              | -- The longest name is 16 characters.
              | 
              | message (longestNameLength [])
              | -- You gotta give me something to work with here.


      section
        .content
          h2 Language Features
          h4.bullet Static types
          pre.bullet
            code.elm
              | type Power = Throw String | Run Int | Shrink
              | 
              | comment: String -> Power -> String
              | comment hero power =
              |   let
              |     subject = hero ++ " can "
              |     predicate =
              |       case power of
              |         Throw name ->
              |            "throw " ++ name
              |         Run speed ->
              |           "run at " ++ (toString speed) ++ " minutes a mile"
              |         Shrink ->
              |           "shrink in size"
              |   in
              |     subject ++ predicate ++ "."

        aside
          p We define a comment function that takes the name of a hero, a Power, and returns a sentence.
          p The case allows destructuring of the tagged value.
          p If there's a new power, we need to add it to the Union Type.
          p Then we have to explicitly account for it everywhere, or the code won't compile.
          p There can be NO runtime exceptions in this code. Guaranteed.


      section
        .content
          h2 Language Features
          h4.bullet Static types
          pre
            code.elm
              | -- type Power = Throw String | Run Int | Shrink
              | -- comment: String -> Power -> String
          br
          pre.bullet
            code.elm
              | List.map (comment "Ant-Man") [Throw "darts", Run 6, Shrink]
              | 
              | {- ["Ant-Man can throw darts.",
              |     "Ant-Man can run at 6 minutes a mile.",
              |     "Ant-Man can shrink in size."] : List String -}
              | 
              | List.map (comment "Captain America") [Throw "shield", Run 4]
              | List.map (comment "Hawkeye") [Throw "Ant-Man", Run 6]

        aside
          p We can map the comment function over a list of Powers.
          p Notice that the comment function is curried.
          p We'll talk about currying and other functional features in a bit.


      section
        .content
          h3.bullet Doing this in JavaScript?
          img.bullet(src="/images/bugs-dazed.jpg")


      section
        .content
          h2.bullet Language Features
          h4.bullet Immutable data structures
          br
          ul
            li Lists and Arrays
            li Sets and Dictionaries
            li Records and Tuples

        aside
          p We've already looked at lists. Arrays are built for positional access.
          p Sets are ideal for set operations.
          p Dictionaries are like hashes, a list of key-value pairs.
          p Arrays, Sets and Dicts have no literal syntax, but can be converted to/from Lists.
          p Records are also key-value pairs, and structurally typed. They are more like JS objects.
          p Tuples are like lightweight records. Values can be different types.


      section
        .content
          h2.bullet Language Features
          h4.bullet Pure Functions
          br
          ul
            li Modularity
            li Composability
            li Destructuring and Pattern Matching
            li Strict management of state

        aside
          p Pure functions:
          p Rely on no other inputs except the arguments
          p Do not modify state outside the function
          p Always return the same values for the same inputs
          p So they are very easy to reason about and test
          p No mocking, confugration


      section
        .content
          h2 Language Features
          h4.bullet Pure Functions
          br
          h3.bullet Modularity
          pre.bullet
            code.elm
              | String.repeat: Int -> String -> String
              | String.padLeft: Int -> Char -> String -> String
              | String.foldl: (Char -> b -> b) -> b -> String -> b
              | > foldl cons "" "time" == "emit"
              | 
              | List.member: a -> List a -> Bool
              | List.intersperse: a -> List a -> List a
              | List.scanl: (a -> b -> b) -> b -> List a -> List b
              | > scanl (+) 0 [1,2,3,4] == [0,1,3,6,10]

        aside
          p Functions can be described entirely by the inputs and the body.
          p This means they don't need to be defined on an object/class.
          p They can be exposed as part of a module, such as utility functions in String and List.
          p It's a good thing we don't have to depend on the npm padLeft module
          p String.foldl: takes a function that can take a char and a type of b and return a type of b,
          p an initial value of type b, and a string (which furnishes the chars) and returns the result of type b.
          p List.scanl: takes a function that can take a type a value and a type b value and return a type b value,
          p an initial value of type b, and a list of type a, and returns the resulting List of type b.


      section
        .content
          h2 Language Features
          h4.bullet Pure Functions
          br
          h3.bullet Composability (Currying)
          br
          pre.bullet
            code.elm
              | String.append
              | -- &lt;function: append&gt; : String -> String -> String
              | hail = String.append "Hail "
              | -- &lt;function&gt; : String -> String
              | List.map hail ["Hydra", "Thanos"]
              | -- ["Hail Hydra","Hail Thanos"] : List String

        aside
          p Functions are curried.
          p Providing fewer arguments than specified returns a function that can take the remaining arguments.
          p The compiler infers the type of `hail` as `String -> String`.
          p This allows passing partially applied functions to higher-order functions.


      section
        .content
          h2 Language Features
          h4.bullet Pure Functions
          br
          h3.bullet Composability (Function Composition)
          br
          pre.bullet
            code.elm
              | List.map (String.append "Hulk " >> String.toUpper) ["smash", "eat", "jump" ]
              | -- ["HULK SMASH","HULK EAT","HULK JUMP"] : List String
              | List.map (String.append "Banner " << String.toLower) ["SMASH", "EAT", "JUMP" ]
              | -- ["Banner smash","Banner eat","Banner jump"] : List String

        aside
          p Functions can be composed in both directions


      section
        .content
          h2 Language Features
          h4.bullet Pure Functions
          br
          h3.bullet Composability (Piping)
          br
          pre.bullet
            code.elm
              | "smash" |> String.append "Hulk " |> String.toUpper
              | -- "HULK SMASH" : String
          br
          pre.bullet
            code.elm
              | ngon 4 75
              | |> filled clearGrey
              | |> move (-10,0)

        aside
          p Also known as chaining or threading in other languages.
          p Functions can be piped in both directions as well.
          p From the Elm examples, drawing a polygon is as simple as this.


      section
        .content
          h2 Language Features
          h4.bullet Pure Functions
          br
          h3.bullet Destructuring and Pattern Matching
          pre.bullet
            code.elm
              | type alias Hero = { name: String, secret_identity: String }
              | 
              | classified_info: Hero -> String
              | classified_info {name, id} =
              |   id ++ " is " ++ name ++ "."
              | 
              | iron_man = Hero "Iron Man" "Tony Stark"
              | 
              | classified_info iron_man
              | -- "Tony Stark is Iron Man." : String


        aside
          p Some of the features of the various data structures we talked about earlier come in useful here.
          p A Type Alias gives us a shorthand for a more lengthy type annotation, with type checks.
          p It also gives us a constructor function for free.
          p There is a proposal out there for doing string interpolation in Elm. For now, we concat.


      section
        .content
          h2 Language Features
          h4.bullet Pure Functions
          br
          h3.bullet Destructuring and Pattern Matching
          pre.bullet
            code.elm


      section
        .content
          h2.bullet Language Features
          h4.bullet JavaScript Interoperability


      section(data-bespoke-backdrop='elm')
        .content
          h1 Functional Reactive Programming (FRP) in Elm


      section
        .content
          h2 FRP in Elm
          <br>
          img.with-bg.bullet(src="/images/arch.png")
          cite
            a(href="http://elm-lang.org/guide/reactivity") &ndash; elm-lang.org

        aside
          p User actions, Ajax, time etc are streams of inputs to the system
          p App state is the result of transformations over time
          p The view is a function of the app state


      section
        .content
          h2 FRP in Elm
          <br>
          img.with-bg.bullet(src="/images/signals.png")
          cite
            a(href="http://elm-lang.org/guide/reactivity") &ndash; elm-lang.org

        aside
          p The central `foldp` is responsible for maintaining the app state across the different input streams.
          p Low-level events are mapped to higher level actions which trigger updates
          p The updates are folded over the app state to generate new state
          p The view reactively renders the new app state
          p This architecture is modular, or "fractal"



    script(src='build/build.js')
